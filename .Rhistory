library('devtools')
check()
use_gpl3_license()
check()
document()
document()
use_testthat()
use_test("TransLasso")
test()
use_package("glmnet")
document()
use_devtools()
library(available)
library('available')
install.packages("available")
available::available("translasso")
check()
document()
check()
check()
#' A method for comparison: Trans-Lasso(l1). It has the same pipeline of Trans.lasso()
#' but with sparsity index R_k=\|w^{(k)}-\beta\|_1 and a naive aggregation (empirical risk minimization)
#'
#' @param X PLACEHOLDER
#' @param y PLACEHOLDER
#' @param n.vec PLACEHOLDER
#' @param I.til PLACEHOLDER
Trans.lasso.sp <- function(X, y, n.vec, I.til, l1=T){
M= length(n.vec)-1
#step 1
X0.til<-X[I.til,] #used for aggregation
y0.til<-y[I.til]
X<- X[-I.til,]
y<-y[-I.til]
#step 2
Rhat <- rep(0, M+1)
p<- ncol(X)
n.vec[1]<- n.vec[1]-length(I.til)
ind.1<-ind.set(n.vec,1)
init.re<-las.kA(X=X, y=y, A0=NULL, n.vec=n.vec, l1=l1)
for(k in 2: (M+1)){
ind.k <- ind.set(n.vec,k)
w.init.k<- as.numeric(glmnet(X[ind.k,], y[ind.k], lambda=init.re$lam.const*sqrt(2*log(p)/length(ind.k)))$beta)
Rhat[k] <-  sum(abs(w.init.k-init.re$beta.kA)) ##\|w^{(k)}-\beta\|_1
}
Tset<- list()
k0=0
kk.list<-unique(rank(Rhat[-1]))
#cat(rank(Rhat[-1]),'\n')
for(kk in 1:length(kk.list)){#use pi.hat as selection rule
Tset[[k0+kk]]<- which(rank(Rhat[-1]) <= kk.list[kk])
}
k0=length(Tset)
Tset<- unique(Tset)
# cat(length(Tset),'\n')
beta.T<-list()
beta.T[[1]] <- init.re$beta.kA
for(kk in 1:length(Tset)){#use pi.hat as selection rule
T.k <- Tset[[kk]]
beta.T[[kk+1]] <-las.kA(X=X, y=y, A0=T.k, lam.const=init.re$lam.const,n.vec=n.vec, l1=l1)$beta.kA
}
beta.T<-beta.T[!duplicated((beta.T))]
beta.T<- as.matrix(as.data.frame(beta.T))
agg.re <- agg.fun(B=beta.T, X.test=X0.til, y.test=y0.til, selection =T)
return(list(beta.sp=agg.re$beta, theta.sp=agg.re$theta, rank.pi=rank(Rhat[-1])))
}
chec()
check()
check()
document()
document()
document()
document()
rm(list = c("Trans.lasso.sp"))
document()
check()
check()
check()
lassoshooting
lassoshooting()
library(lassoshooting)
document()
document()
document()
document()
document()
document()
check()
document()
use_package("lassoshooting")
document()
check()
load_all()
######A method for comparison: it has the same pipeline of the Trans-Lasso
###but with sparsity index R_k=\|w^{(k)}-\beta\|_1 and a naive aggregation (empirical risk minimization)
prop.sp.re1 <- Trans.lasso.sp(X, y, n.vec, I.til = 1:50, l1 = l1)
cat(Rank.re, '\n')
Rank.re <- 0
dput(Rank.re)
print('Rank.re:\n')
Coef.gen<- function(s, h,q=30, size.A0, M, sig.beta,sig.delta1, sig.delta2, p, exact=T){
beta0 <- c(rep(sig.beta,s), rep(0, p - s))
W <- rep.col(beta0,  M)# ten prior estimates
W[1,]<-W[1,]-2*sig.beta
for(k in 1:M){
if(k <= size.A0){
if(exact){
samp0<- sample(1:p, h, replace=F)
W[samp0,k] <-W[samp0,k] + rep(-sig.delta1, h)
}else{
W[1:100,k] <-W[1:100,k] + rnorm(100, 0, h/100)
}
}else{
if(exact){
samp1 <- sample(1:p, q, replace = F)
W[samp1,k] <- W[samp1,k] + rep(-sig.delta2,q)
}else{
W[1:100,k] <-W[1:100,k] + rnorm(100, 0, q/100)
}
}
}
return(list(W=W, beta0=beta0))
}
set.seed(123)
if(exact){
samp1 <- sample(1:p, q, replace = F)
W[samp1,k] <- W[samp1,k] + rep(-sig.delta2,q)
}else{
W[1:100,k] <-W[1:100,k] + rnorm(100, 0, q/100)
}
?source
######A method for comparison: it has the same pipeline of the Trans-Lasso
###but with sparsity index R_k=\|w^{(k)}-\beta\|_1 and a naive aggregation (empirical risk minimization)
prop.sp.re1 <- Trans.lasso.sp(X, y, n.vec, I.til = 1:50, l1 = l1)
######A method for comparison: it has the same pipeline of the Trans-Lasso
###but with sparsity index R_k=\|w^{(k)}-\beta\|_1 and a naive aggregation (empirical risk minimization)
n.vec <- c(n0, rep(100, M))
M = 20
?cat
dput(Rank.re.sp)
test()
library(SimDesign)
package.install('SimDesign')
install.packages('SimDesign')
test()
test()
test()
test()
test()
test()
test()
test()
usethis::use_github_action_check_standard()
usethis::use_coverage("codecov")
usethis::use_github_action("test-coverage")
use_package("SimDesign")
usethis::use_pkgdown()
usethis::use_github_action("pkgdown")
test()
test()
test()
test()
test()
test()
test()
document()
check()
check()
?cbind
install.packages('translasso')
install.packages("translasso")
?cbind
test()
library('usethis')
test()
library('devtools')
test()
test()
test()
test()
?list2env
test()
test()
test()
test()
test()
test()
test()
test()
test()
test()
document()
test()
?rep
rep(100, 20)
c(150, rep(100, 20))
c(150, rep(100, 20))[1]
c(150, rep(100, 20))[[1]]
document()
test()
test()
test()
test()
test()
test()
create_package("/mnt/d/Penn/HongzhePackages/TransCLIME")
create_package("../TransCLIME")
library('devtools')
document()
library('devtools')
library('devtools')
update.packages('cli')
library('devtools')
update.packages(cli)
library(devtools)
update.packages('cli')
library('cli')
library('devtools')
renv::activate()
library('devtools')
install.packages('devtools')
library('devtools')
document()
?summary
?print
document()
?agg.fun
document()
create_package('../Spectral-Permutation-Recovery')
library('devtoos')
library('devtools')
create_package('../Spectral-Permutation-Recovery')
create_package('../SpectralPermutationRecovery')
